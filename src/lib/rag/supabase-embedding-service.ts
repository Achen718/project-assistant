import { supabaseAdmin } from '../supabase/client';
import { EmbeddedChunk, SupabaseEmbeddingRow, SearchResult } from './types';
import { PostgrestError } from '@supabase/supabase-js';

export const EMBEDDINGS_TABLE_NAME = 'document_chunks';
export const MATCH_FUNCTION_NAME = 'match_document_chunks_custom';

/**
 * Stores an array of embedded chunks in Supabase.
 * Assumes `id` and `created_at` are auto-generated by the database.
 * @param embeddedChunks Array of chunks to store (must include userId).
 * @returns An object with the count of successfully stored items and any errors.
 */
export async function storeEmbeddings(
  embeddedChunks: EmbeddedChunk[]
): Promise<{
  storedCount: number;
  errors: { item: EmbeddedChunk; error: PostgrestError }[];
}> {
  if (!embeddedChunks || embeddedChunks.length === 0) {
    return { storedCount: 0, errors: [] };
  }

  const rowsToInsert: Array<Omit<SupabaseEmbeddingRow, 'id' | 'created_at'>> =
    embeddedChunks.map((chunk) => ({
      project_id: chunk.projectId,
      user_id: chunk.userId,
      file_path: chunk.filePath,
      chunk_text: chunk.content,
      embedding: chunk.embedding,
      start_char_offset: chunk.startLine,
      end_char_offset: chunk.endLine,
      chunk_sequence_number: chunk.chunkIndex,
    }));

  const { error } = await supabaseAdmin
    .from(EMBEDDINGS_TABLE_NAME)
    .insert(rowsToInsert);

  let storedCount = 0;
  const errors: { item: EmbeddedChunk; error: PostgrestError }[] = [];

  if (error) {
    console.error('[storeEmbeddings] Error inserting embeddings:', error);
    embeddedChunks.forEach((chunk) => errors.push({ item: chunk, error }));
  } else {
    storedCount = embeddedChunks.length;
    console.log(
      `[storeEmbeddings] Successfully initiated storage of ${storedCount} embeddings.`
    );
  }

  return { storedCount, errors };
}

/**
 * Searches for embeddings similar to the query embedding within a specific project and for a specific user.
 * @param projectId The UUID of the project to search within.
 * @param userId The UUID of the user performing the search (to scope results).
 * @param queryEmbedding The embedding vector to search for.
 * @param matchThreshold The similarity threshold.
 * @param matchCount The maximum number of results to return.
 * @returns An array of SearchResult objects.
 */
export async function searchSimilarEmbeddings(
  projectId: string,
  userId: string,
  queryEmbedding: number[],
  matchThreshold: number = 0.7,
  matchCount: number = 10
): Promise<SearchResult[]> {
  if (!queryEmbedding || queryEmbedding.length === 0) {
    return [];
  }

  const { data, error } = await supabaseAdmin.rpc(MATCH_FUNCTION_NAME, {
    p_query_embedding: queryEmbedding,
    p_match_threshold: matchThreshold,
    p_match_count: matchCount,
    p_project_id: projectId,
    p_user_id: userId,
  });

  if (error) {
    console.error(
      '[searchSimilarEmbeddings] Error searching embeddings:',
      error
    );
    return [];
  }

  return (data || []).map(
    (row: Partial<SearchResult> & { similarity: number }) => ({
      id: row.id || ' ',
      project_id: row.project_id || projectId,
      user_id: row.user_id || userId,
      file_path: row.file_path || 'unknown',
      chunk_text: row.chunk_text || '',
      start_char_offset: row.start_char_offset,
      end_char_offset: row.end_char_offset,
      chunk_sequence_number: row.chunk_sequence_number,
      similarity: row.similarity,
      created_at: row.created_at || new Date().toISOString(),
    })
  );
}

// ---- Supabase SQL for setting up the custom match function ----
/* 

SQL Setup Instructions:

1. Ensure pgvector extension is enabled (run once per database):
   -- CREATE EXTENSION IF NOT EXISTS vector;

2. Create the custom match function for your `document_chunks` table.
   This function assumes your `document_chunks` table and `projects` table exist as per your schema.
   Make sure the VECTOR dimension (e.g., 384) matches your embedding model.

   -- CREATE OR REPLACE FUNCTION match_document_chunks_custom (
   --   p_query_embedding VECTOR(384),
   --   p_project_id UUID,
   --   p_user_id UUID,
   --   p_match_threshold FLOAT,
   --   p_match_count INTEGER
   -- )
   -- RETURNS TABLE (
   --   id UUID,
   --   project_id UUID,
   --   user_id UUID,
   --   file_path TEXT,
   --   chunk_text TEXT,
   --   start_char_offset INTEGER,
   --   end_char_offset INTEGER,
   --   chunk_sequence_number INTEGER,
   --   created_at TIMESTAMPTZ,
   --   similarity FLOAT
   -- )
   -- LANGUAGE plpgsql
   -- AS $$
   -- BEGIN
   --   -- Optional: Check project access if not handled by RLS
   --   -- IF NOT EXISTS (SELECT 1 FROM projects p WHERE p.id = p_project_id AND p.user_id = p_user_id) THEN
   --   --   RAISE EXCEPTION 'User does not have access to this project';
   --   -- END IF;
   -- 
   --   RETURN QUERY
   --   SELECT
   --     dc.id,
   --     dc.project_id,
   --     dc.user_id,
   --     dc.file_path,
   --     dc.chunk_text,
   --     dc.start_char_offset,
   --     dc.end_char_offset,
   --     dc.chunk_sequence_number,
   --     dc.created_at,
   --     1 - (dc.embedding <=> p_query_embedding) AS similarity
   --   FROM
   --     document_chunks dc
   --   WHERE 
   --     dc.project_id = p_project_id AND dc.user_id = p_user_id
   --     AND (1 - (dc.embedding <=> p_query_embedding)) > p_match_threshold
   --   ORDER BY
   --     similarity DESC
   --   LIMIT
   --     p_match_count;
   -- END;
   -- $$;

3. Example of how to call the function in SQL:
   -- SELECT * FROM match_document_chunks_custom(
   --   ARRAY[0.1, 0.2, 0.3], -- example embedding vector
   --   'replace-with-project-uuid', 
   --   'replace-with-user-uuid', 
   --   0.7, 
   --   10
   -- );

4. Reminder about indexing on your `embedding` column in `document_chunks`:
   You already have an IVFFlat index: idx_document_chunks_embedding_ivfflat.
   Monitor its performance. For alternative HNSW indexing, you could use:
   -- CREATE INDEX IF NOT EXISTS idx_document_chunks_embedding_hnsw 
   -- ON public.document_chunks USING hnsw (embedding extensions.vector_cosine_ops);

*/
